= GUI =

== Краткое руководство ==

Интерфейс разбит на три части:
    # Слева: видимая часть файловой системы.
    # Справа: скрытая часть файловой системы.
    # Сверху: поле для непосредственного выбора файла.

Расположенное вверху текстовое поле позволяет вводить путь к файлу вручную.
Также есть возможность выбора файла с помощью стандартного системного диалога
(кнопка справа от поля). В случае ручного ввода пути требуется нажатие Enter
для подтверждения.

Отображаемый путь обновляется при выборе файлов или директорий на графических
представлениях. В случае выбора ещё не скрытого файла будет установлен его путь.
В случае выбора скрытого файла устанавливается путь к ближайшей не скрытой
директории, в которую вложен выбранный файл.

=== Скрытие файлов ===

Выбранный файл или директория скрываются с помощью соответствующей кнопки.
В данный момент поддерживается выбор только одного файла или директории.

Чекбокс «Recursive» определяет способ скрытия директорий:
    * установлен: рекурсивно скрываются дочерние директории, а также всё содержимое и сама директория;
    * не установлен: скрываются только файлы (но не дочерние директории), находящиеся в выбранной директории;
    * на скрытие отдельных файлов никак не влияет.

Чекбокс «Hide symlink target» определяет способ скрытия символических ссылок:
    * установлен: скрывается и сам файл-ссылка, и адресуемый ею файл;
    * не установлен: скрывается только сам файл-ссылка.

==== Возможные ошибки ====

    * Не найден файл устройства.
        * Проверьте загружен ли модуль ядра.
        * Выберите альтернативное расположение файла устройства с помощью диалога.
    * Файл устройства не может быть открыт.
        * Проверьте наличие прав на запись и чтение из файла. По умолчанию они есть только у root.
    * Файл устройства занят.
        * Другой процесс в данный момент использует файл устройства.
    * Попытка скрыть точку монтирования.
    * Внутренние проблемы модуля.

=== Показ файлов ===

Выбранный скрытый файл или директория показываются с помощью соответствующей
кнопки. В данный момент поддерживается выбор только одного файла или директории.
Также можно показать все скрытые файлы с помощью соответствующей кнопки.

Директории могут быть как скрытыми, так и нет. Видимые директории отображаются
для удобства навигации. Скрытые в данный момент директории имеют полупрозрачную
иконку. Все отображамые файлы являются скрытыми.

Чекбокс «Recursive» определяет способ показа директорий:
    * установлен: восстанавливается всё содержимое директории, а также она сама;
    * не установлен: показывается только сама директория, содержимое остаётся скрытым.

==== Возможные ошибки ====

    * Не найден файл устройства.
        * Проверьте загружен ли модуль ядра.
        * Выберите альтернативное расположение файла устройства с помощью диалога.
    * Файл устройства не может быть открыт.
        * Проверьте наличие прав на запись и чтение из файла. По умолчанию они есть только у root.
    * Файл устройства занят.
        * Другой процесс в данный момент использует файл устройства.
    * Попытка показать файл, принадлежащий скрытой директории.
        * Существует возможность показать все скрытые директории, которые мешают показать данный файл.
    * Внутренние проблемы модуля.

= Файл устройства =

== API ==

Файл устройства создаётся полуавтоматически API Linux для файлов устройств.
Обычно получается файл `/dev/hcontrol`. Хозяин: root, права: `rw-------` (`0600`).

Запись в файл передаёт команды модулю:
    * `H /absolute/path/to/file` — спрятать файл с указанным путём;
    * `U <номер inode>` — показать скрытый файл с указанным номером;
    * `C` — показать все скрытые файлы.

После выполнения команды из файла можно прочитать результат. Ошибки
сообщаются строками вида `E-<номер ошибки>`.
    * `H` возвращает номер inode скрытого файла, используемый для его идентификации внутри модуля (в частности, для показа файла обратно);
          *  `-EINVAL` — неправильный формат
          *  `-ENOENT` — файл не существует
          *  `-EPERM`  — попытка скрыть точку монтирования или её непосредственного потомка
          *  `-EEXIST` — файл уже скрыт
          *  `-ENOMEM` — не удалось выделить память под внутренние структуры
    * `U` возвращает номер inode показанного файла;
          *  `-EINVAL`    — неправильный формат
          *  `-ENOENT`    — такой файл не скрыт
          *  `-ENOTEMPTY` — попытка показать файл, не показав при этом его скрытого родителя
          *  `-EBADF`     — внутренняя проблема: файл потерял родителя
    * `C` возвращает строку `0`.

=== Детали/особенности ===

Major number выделяется динамически, minor number 0.

Файл может быть открыт только одним процессом в один момент времени.

Открытый файл устройства не даёт выгрузить модуль из памяти.

Необходимо записывать/читать всё сообщение за одну операцию. Максимальные размеры
буферов:
  * 512 байтов — ввод;
  * 40 байтов — вывод.


= Технические детали реализации =

== Принцип скрытия ==

Virtual File System — абстракция Linux для взаимодействия с различными файловыми
системами. Центральные понятия VFS:
    * inode — объект ядра, олицетворение файла на диске; хранится в памяти, время от времени переписываются на диск;
    * dentry — связывает inode и _путь к файлу_; существует только в памяти, является «хранителем» файловой структуры (сами inode не хранят иерархию файлов).
    * file — объект ядра, олицетворение открытого процессов файла; именно он, к примеру, хранит информацию о положении «считывающей головки».

Кроме всего прочего, у структуры inode есть несколько полей, которые можно
использовать с целью скрытия:
  * `struct inode_operations *i_op` — содержит указатели на методы конкретной inode, отвечающие за взаимодействие с файловой системой на уровне её структуры: создание/удаление файлов и директорий, переименование, запрос атрибутов и т. п.;
  * `struct file_operations *i_fop` — содержит указатели на методы файлов, соответствующих данной inode; они отвечают за взаимодействие с содержимым файла: открытие, закрытие, чтение/запись; для директорий: чтение списка содержимого.

Если подменить данные структуры на специальным образом сформированные свои,
то можно заставить VFS считать, что какого-то файла не существует.

=== Обработка файла ===

Для самого файла достаточно заменить его `inode_operations` и `file_operations`.
Все они должны возвращать код ошибки `-ENOENT`, означающий, что искомого файла
не существует.

Например, метод открытия файла:
{{{
static int notfound_open(struct inode *inode, struct file *file)
{
        return -ENOENT;
}
}}}

При обработке системых вызовов вроде `open()` и `read()` ОС обращается к VFS, а она
в свою очередь обращается к соотвествующим методам inode, а они в свою очередь
должны обращаться к конкретному драйверу конкретной файловой системы. Замена
методов на такие заглушки симулирует ответ соответствующий ответ драйвера об
отсутствии файлов.

=== Обработка родительской директории ===

В VFS подсистема поиска файлов по имени не зависит от собственно содержимого
inode. Именно поэтому отдельно заменяются методы inode, так как существует
возможность обращения к ним не только по имени файла, но и, например, через
ранее открытый файловый дескриптор.

Кроме этого необходимо изъять скрываемый файл из списка содержимого его
родительской директории. Этот список формируется при вызове метода `readdir()`
хранящегося в `file_operations` родительской директории. Этот метод убеждается
в существовании директории, проверяет права доступа и т. д. В общем, имеет
сложную логику. Вот его прототип:
{{{
int readdir(struct file *dir, void *data, filldir_t filldir);
}}}

За собственно заполнение конкретного элемента списка отвечает функция `filldir()`,
указатель на которую (`filldir_t`) передаётся в `readdir()`.
{{{
int filldir(void *buffer, const char *name, int namelen, loff_t offset, u64 ino, unsigned d_type);
}}}

Её подмена и даёт возможность скрыть конкретный файл из содержимого директории.
Для этого достаточно просто не заполнять соответствующую запись списка содержимого.
Скрытые файлы идентифицируются по номеру их inode (`ino`), услужливо передаваемому
внутрь `filldir()`.
{{{
static int filtering_filldir(void *buffer, const char *name, int namelen,
                             loff_t offset, u64 ino, unsigned d_type)
{
        /* если файл скрыт */
        if (humble_hash_contains(ino)) {
                return 0;
        }
        return g_original_filldir(buffer, name, namelen, offset, ino, d_type);
}
}}}

Так как новые аргументы вводить нельзя, то придётся использовать глобальную
переменную для передачи указателя на настоящую `filldir()`, которая, очевидно,
нужна для заполения информации о видимых файлах.

Текущая ситуация в ядре (версии 3.2) такая, что все распространённые файловые
системы пользуются одной-единственной стандартной `filldir()`, предоставляемой
VFS, так что (под честное слово) можно не синхронизировать доступ к этой глобальной
переменной, потому как она может указывать только на два места: стандартную `filldir()`
и фильтрующую `filldir()`. Последнее возможно только в случае ошибки со стороны
этого драйвера и приведёт к бесконечному циклу; поэтому на всякий случай при
обновлении значения данной переменной проводится соответствующая проверка.

Проблема: как передать эту `filldir()` внутрь `readdir()` родительской директории?
Было использовано простейшее решение (_хак-хак_): подменить `readdir()` на свою
обёртку, которая сохраняет оригинальную `filldir()` в глобальной переменной
и вызывает оригинальную `readdir()` с фильтрующей `filldir()`. В качестве
оригинальной можно взять или `readdir()` по умолчанию из суперблока, или же
сохранённую в исходной структуре `file_operations` родительской директории. Ради
простоты был выбран первый вариант.
{{{
static int filtering_readdir(struct file *dir, void *data, filldir_t filldir)
{
        if (filldir != filtering_filldir) {
                g_original_filldir = filldir;
        }
        return dir->f_dentry->d_sb->s_root->d_inode->i_fop
                ->readdir(dir, data, filtering_filldir);
}
}}}

Как и любое простое решение, оно не лишено недостатков. Именно из-за замены
`readdir()` родительской директории и необходимости обращения к `readdir()`
суперблока появился запрет на скрытие точки монтирования и её непосредственных
потомков.

Кроме того, in-memory файловые системы не переносят наглого вмешательства в их
структуру при замене `readdir()`, поэтому попытка скрыть их содержимое оборачивается
_Oops!_ от ядра.

=== Контракт директорий ===

Следуя принципу «минимум работы в kernel-mode», драйвер умеет скрывать только
по одному файлу за раз. Ввиду технологии скрытия, подразумевающей замену 
внутренних структур данных, для скрытия директории необходимо выполнить
следующие действия в строго определённом порядке:
    # Скрыть всё её содержимое.
    # Скрыть саму директорию.
Аналогично для показа:
    # Показать саму директорию.
    # Показать её содержимое.
Рекурсивный обход файловой системы и формирование списка скрываемых файлов
в правильном порядке возлагается на пользователей драйвера.

Случай неправильного порядка при показе может быть обнаружен относительно легко,
поэтому он учитывается. Обнаружение неправильного порядка при скрытии потребовало
бы обращения к файловой системе из kernel-space, что не очень хорошо, поэтому
данное ограничение сформировано в виде контракта: пользователь _обязан_ следить
за правильным порядком скрытия директорий, иначе возможно возникновение аномалий
в видимой структуре файловой системы.


== Хеш-таблица ==

Так как файлы необходимо не только скрывать, но и показывать обратно по желанию,
необходима структура данных, которая бы хранила список скрытых файлов, а также
позволяла бы быструю проверку на вхождение конкретного файла в перечень скрытых.
Очевидно, здесь идеально подходит хеш-таблица.

В ядро Linux уже включены некоторые вспомогательные возможности: односвязные
списки в `<linux/list.h>`, а также хорошая хеш-функция в `<linux/hash.h>`, так
что сборка хеш-таблицы из стандартных компонентов не составляет труда.

=== Данные ===

Каждый скрытый файл должен хранить оригинальные `*_operations`, чтобы их можно
было восстановить, а также ссылку на своего родителя, так как его
`file_operations` тоже надо будет восстанавливать. Также в каждой родительской
директории можно быть несколько скрытых файлов, убирать родителя из списка
необходимо тогда, когда в соответствующей директории не осталось скрытых файлов.
Поэтому родитель также хранит счётчик принадлежащих ему скрытых файлов.
{{{
struct hash_entry_parent {
        struct hlist_node      link;

        struct inode           *inode;
        struct file_operations *old_fops;

        int                    hidden_cnt;
};

struct hash_entry_file {
        struct hlist_node        link;

        struct inode             *inode;
        struct inode_operations  *old_iops;
        struct file_operations   *old_fops;

        struct hash_entry_parent *parent;
};
}}}

=== Важные мелочи ===

В элементах хранятся указатели на inodes. Так как они там _хранятся_, а
не быстро временно используются, то необходимо соответствующим образом обновлять
их счётчики ссылок — `ihold()`/`iput()`. Это не даст ОС выгрузить inodes скрытых
файлов из памяти, так что ничего не будет угрожать подменённым `*_operations`.

Кроме того, очевидно, что несколько потоков могут пользоваться хеш-таблицей,
так что требуется некоторая синхронизация. В данном сценарии замечательно
подходит read-write lock. Соответствующий системный примитив и используется
для синхронизации доступа к хеш-таблице при запросах «скрытости» файлов и
добавлении/удалении записей.